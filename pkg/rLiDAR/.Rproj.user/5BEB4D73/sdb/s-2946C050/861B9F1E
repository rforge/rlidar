{
    "contents" : "#'Deriving the ground-projected canopy area of individual trees using LiDAR \n#'\n#'@description Compute and export the ground-projected areas of individual tree canopies detected within the LiDAR-derived Canopy Height Model (CHM) \n#'\n#'@usage ForestCAS(chm, loc, maxcrown, exclusion)\n#'\n#'@param chm A LiDAR-derived Canopy Height Model (CHM) RasterLayer or SpatialGridDataFrame file.\n#'@param loc A matrix or dataframe with three columns (tree xy coordinates and height).\n#'@param maxcrown A single value of the maximum individual tree crown radius expected. Default 10.0 m.\n#'@param exclusion A single value from 0 to 1 that represents the \\out{\\%} of pixel exclusion. E.g. a value of 0.5 will exclude all of the pixels for a single tree that has a height value of less than 50\\out{\\%} of the maximum height from the same tree. Default value is 0.3. \n#'@return Returns a list that contains the individual tree canopy boundary polygons and the 4-column matrix with the tree xy coordinates, heights and ground-projected canopy area (with units of square meters).  \n#'@author Carlos Alberto Silva\n#'@examples\n#'\\dontrun{\n#'\n#'# Import the LiDAR-derived CHM file\n#'data(chm) # or set a CHM. e.g. chm<-raster(\"CHM_stand.asc\") \n#'\n#'# Set the loc parameter\n#'sCHM<-CHMsmoothing(chm, filter=\"mean\", ws=5) # smoothing CHM\n#'loc<-FindTreesCHM(sCHM, fws=5, minht=8) # or import a tree list\n#'\n#'# Set the maxcrown parameter\n#'maxcrown=10.0 \n#'\n#'# Set the exclusion parameter\n#'exclusion=0.3 # 30\n#'\n#'# Compute individual tree detection canopy area\n#'canopy<-ForestCAS(chm, loc, maxcrown, exclusion)\n#'\n#'#==================================================================================#\n#'# Retrieving the boundary for individual tree detection and canopy area calculation\n#'#==================================================================================#\n#'boundaryTrees<-canopy[[1]]\n#\n#'# Plotting the individual tree canopy boundary over the CHM\n#'plot(chm, main=\"LiDAR-derived CHM\") \n#'plot(boundaryTrees, add=T, border='red', bg='transparent') # adding tree canopy boundary\n#'\n#'#============================================================================#\n#'# Retrieving the list of individual trees detected for canopy area calculation\n#'#============================================================================#\n#'canopyList<-canopy[[2]] # list of ground-projected areas of individual tree canopies\n#'summary(canopyList)     # summary \n#'\n#'# Spatial location of the trees\n#'XY<-SpatialPoints(canopyList[,1:2])    # Spatial points\n#'plot(XY, col=\"black\", add=T, pch=\"*\") # adding tree location to the plot\n#'} \n#'@importFrom spatstat disc\n#'@importFrom sp coordinates gridded Polygon Polygons SpatialPolygons over\n#'@importFrom sp over SpatialPoints SpatialPolygonsDataFrame SpatialGridDataFrame\n#'@importFrom deldir tile.list deldir \n#'@importFrom plyr ddply\n#'@importFrom raster raster rasterToPolygons boundaries\n#'@export\nForestCAS<-function(chm,loc,maxcrown=10,exclusion=0.3) {\n\n  if (class(chm)!=\"RasterLayer\" & class(chm)!=\"SpatialGridDataFrame\") {stop(\"The chm is invalid. It must to be a RasterLayer or SpatialGridDataFrame'\")}\n  if (ncol(loc)!=3) {stop(\"The input loc is invalid. It must to be 3-column matrix or dataframe with the x,y coordinates and heights of the individual trees\")}\n  if (class(maxcrown)!=\"numeric\") {stop(\"The maxcrown parameter is invalid. It is not a numeric input\")}\n  if (class(exclusion)!=\"numeric\") {stop(\"The exclusion parameter is invalid. It is not a numeric input\")}\n  if (exclusion >=1) {stop(\"The exclusion parameter is invalid. It must to be less than 1numeric input\")}\n\n  if (class(chm)==\"RasterLayer\"){ chm<-as(chm, \"SpatialGridDataFrame\")}\n    \n  Hthreshold<-min(loc[,3])*exclusion\n  polys<-list() \n  width<-numeric()  \n  \n  for(i in 1:nrow(loc)) { \n    width[i]=maxcrown\n    discbuff<-disc(radius=width[i], centre=c(loc$x[i], loc$y[i])) \n    discpoly<-Polygon(rbind(cbind(discbuff$bdry[[1]]$x, \n                                  y=discbuff$bdry[[1]]$y), c(discbuff$bdry[[1]]$x[1], \n                                                             y=discbuff$bdry[[1]]$y[1]))) \n    polys<-c(polys, discpoly) \n  } \n  \n  spolys<-list() \n  for(i in 1:length(polys)) { \n    spolybuff<-Polygons(list(polys[[i]]), ID=row.names(loc)[i]) \n    spolys<-c(spolys, spolybuff) \n  } \n  polybuffs<-SpatialPolygons(spolys) \n\n  chmdf<-as.data.frame(chm,xy=TRUE)\n  Points.Ply<-over(SpatialPoints(chmdf[,2:3]),polybuffs) \n  Points.PlyD<-cbind(chmdf,Points.Ply) \n  Points.PlyD<-na.omit(Points.PlyD) \n  vor =  deldir(loc[,1], loc[,2], z=loc[,3],suppressMsge=T)\n  tile = tile.list(vor)\n  polys = vector(mode='list', length=length(tile))\n  \n for (i in seq(along=polys)) {\n    pcrds = cbind(tile[[i]]$x, tile[[i]]$y)\n    pcrds = rbind(pcrds, pcrds[1,])\n    polys[[i]] = Polygons(list(Polygon(pcrds)), ID=as.character(i))\n  }\n  \n  SP = SpatialPolygons(polys)\n  veronoi = SpatialPolygonsDataFrame(SP, data=data.frame(x=loc[,1], \n                                                         y=loc[,2], row.names=sapply(slot(SP, 'polygons'), \n                                                                                          function(x) slot(x, 'ID'))))\n  chmV<-over(SpatialPoints(Points.PlyD[,2:3]), SP)\n  RpD<-cbind(Points.PlyD,chmV)\n  RpD.filter<-subset(RpD[,1:5],RpD[,1]>=Hthreshold)\n  RpD.filter<-cbind(RpD.filter[,1:3],RpD.filter[,5])\n  colnames(RpD.filter)<-c(\"z\",\"x\",\"y\",\"g\")\n  h.mH<-ddply(RpD.filter,\"g\", function (RpD.filter)\n    subset(RpD.filter,RpD.filter[,1]>= max(RpD.filter[,1])*exclusion))\n   \n  for ( j in 1:nlevels(factor(h.mH[,4]))){\n    assign(paste0(\"SP.polys\", j), DF2raster(h.mH,j))\n    cat (\".\");flush.console()}\n  \n  polygons <- slot(get(\"SP.polys1\"), \"polygons\")\n  \n  for (i in 1:nlevels(factor(h.mH[,4]))) {\n    data.loc <- get(paste0(\"SP.polys\",i))\n    polygons <- c(slot(data.loc, \"polygons\"),polygons)\n  }\n  \n  for (i in 1:length(polygons)) {\n    slot(polygons[[i]], \"ID\") <- paste(i)\n  }\n  \n  spatialPolygons <- SpatialPolygons(polygons)\n  spdf <- SpatialPolygonsDataFrame(spatialPolygons, \n                                   data.frame(Trees=1:length(polygons)))\n  \n  options(scipen=10)\n  spdf<-spdf[spdf@data[-length(polygons),],]\n  areaList<-sapply(slot(spdf, \"polygons\"), slot, \"area\")\n  canopyTable<-cbind(loc,areaList)\n  colnames(canopyTable)<-c(\"x\",\"y\",\"z\",\"ca\")\n  result=list(spdf,canopyTable) \n  return(result)\n  \n}",
    "created" : 1425976454558.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1866513382",
    "id" : "861B9F1E",
    "lastKnownWriteTime" : 1425976467,
    "path" : "~/rLiDAR/rLiDAR/R/ForestCAS.R",
    "project_path" : "R/ForestCAS.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}
{
    "contents" : "data(iris)\ninTrain<-createDataPartition(y=iris$Species,p=0.7,list=FALSE)\n\ntraining<-iris[inTrain,]\ntesting<-iris[-inTrain,]\n\nmodFit<-train(Species~.,data=training,method=\"rf\",prox=TRUE)\nmodFit\n\ngetTree(modFit$finalModel,k=2)\n\n\npred<-predict(modFit,testing)\ntesting$predRight <-pred==testing$Species\ntable(pred,testing$Species)\n\n####################\n\n#----------------------------------------------------------------------------------------------------------###\n# 1 set a workspace\n#----------------------------------------------------------------------------------------------------------###\ndir<-\"C:\\\\08_Pinus_sp_PTA\"\nsetwd(dir)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 2. Load lidar plot data\n#----------------------------------------------------------------------------------------------------------###\nlidarData <- read.csv(file=paste0(dir,\"\\\\01_inputdata\\\\LiDAR_sp_PTA2.csv\"), sep=\",\", header=TRUE)\ncolnames(lidarData) # columms names\nhead(lidarData)\nnrow(lidarData)\nhead(lidarData)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 3. Explore relationships between stand volume and LiDAR predictor variables\n#----------------------------------------------------------------------------------------------------------###\n#3.1 Response variable\nhist(lidarData$total)\nhist(lidarData$comercial)\n\nlidarData<-subset(lidarData,lidarData$total<=30)\nlidarData<-subset(lidarData,lidarData$Elev.maximum<20)\nResponseV <- (lidarData$total * 10000)/lidarData$plotarea\n#hist(ResponseV)\n\n#----------------------------------------------------------------------------------------------------------###\n#3.2 LiDAR metrics\nKeepMetrics<-c(\"Elev.maximum\",\"Elev.mean\",\"Elev.mode\",\"Elev.stddev\",\"Elev.variance\",\"Elev.CV\",\"Elev.IQ\",\"Elev.skewness\",\"Elev.kurtosis\",\n               \"Elev.P01\",\"Elev.P05\",\"Elev.P10\",\"Elev.P20\",\"Elev.P25\",\"Elev.P30\",\"Elev.P40\",\"Elev.P50\",\"Elev.P60\",\"Elev.P70\",\"Elev.P75\",\n               \"Elev.P80\",\"Elev.P90\",\"Elev.P95\",\"Elev.P99\",\"Percentage.first.returns.above.1.37\")\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 4. Explore accessing variables and subsetting\n#----------------------------------------------------------------------------------------------------------###\n\ninTrain<-createDataPartition(y=lidarData[,5],p=0.8,list=F)\n\ntraining<-lidarData[inTrain,]\ntesting<-lidarData[-inTrain,]\n\nResponseV<-lidarData[,c(\"comercial\",\"total\",\"celulose\")]\nResponseV <- (ResponseV * 10000)/lidarData$plotarea\n\n#----------------------------------------------------------------------------------------------------------###\n#3.2 LiDAR metrics\nKeepMetrics<-c(\"Elev.maximum\",\"Elev.mean\",\"Elev.mode\",\"Elev.stddev\",\"Elev.variance\",\"Elev.CV\",\"Elev.IQ\",\"Elev.skewness\",\"Elev.kurtosis\",\n               \"Elev.P01\",\"Elev.P05\",\"Elev.P10\",\"Elev.P20\",\"Elev.P25\",\"Elev.P30\",\"Elev.P40\",\"Elev.P50\",\"Elev.P60\",\"Elev.P70\",\"Elev.P75\",\n               \"Elev.P80\",\"Elev.P90\",\"Elev.P95\",\"Elev.P99\",\"Percentage.first.returns.above.1.37\")\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 4. Explore accessing variables and subsetting\n#----------------------------------------------------------------------------------------------------------###\nlidarData<-cbind(ResponseV,lidarData[,KeepMetrics])\nlidarData<-cbind(ResponseV,lidarData[,45:ncol(lidarData)])\n\ncolnames(lidarData) # columms names\nncol(lidarData) # numeric of the columms\nrownames(lidarData) # row names\nnrow(lidarData) # numeric of the rows\nplot(lidarData$Elev.maximum, ResponseV )\ncor(lidarData$Elev.maximum, ResponseV)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 5. Generate a correlation matrix\n#----------------------------------------------------------------------------------------------------------###\ncorLidarData<-lidarData[,-c(1:3)]\ncorrMat <- cor(corLidarData)\nprint(corrMat)\n\n# remove the variables high correlated ( cor > 0.90)\ncorrMat[upper.tri(corrMat)] <- 0\ndiag(corrMat) <- 0\nlidarData.new <- corLidarData[, apply(corrMat,2,function(x) all(x<=0.90))]\nhead(lidarData.new)\ncorrMat <- cor(lidarData.new);print(corrMat) # new correlation to check \n#----------------------------------------------------------------------------------------------------------###\n\n\n\n# require package\nrequire(randomForest)\n\n# source var. selection function : \nsource(\"C:\\\\Users\\\\Carlos\\\\Documents\\\\PhD_UIdaho\\\\01_Classes\\\\FALL2014\\\\FOR504_02_STComputational_Data_Analysis\\\\Assignments\\\\Assignment5\\\\rf.modelSel.R\")\n\n# find the best variables\nvarsSelec<-data.frame()\n\n\nfor ( i in 1:100) {\n  ( rf.regress <- rf.modelSel(lidarData.new, ResponseV[,1], parsimony=0.03) )\n  IV<-cbind(rownames(rf.regress$IMPORTANCE[1]),rf.regress$IMPORTANCE[[1]])\n  varsSelec<-rbind(varsSelec,IV)\n}\n\nnV<-tapply(as.numeric(paste0(varsSelec[,2])),paste0(varsSelec[,1]),length)\nMIR=tapply(as.numeric(paste0(varsSelec[,2])),paste0(varsSelec[,1]),mean)\n\nvarSelected<-c(\"Elev.P99\",\"Elev.CV\")\n\nset.seed(1)\n#( rf.fit <- randomForest(ResponseV~lidarData.new[,varSelected][,1],importance=TRUE, mtry=1,na.action=na.omit,ntree=1000,keep.forest=TRUE))\n\n(rf.fit <- randomForest(x=lidarData.new, y=ResponseV[,1],importance=TRUE, na.action=na.omit,mtry=1, ntree=1000, \n                        keep.forest=TRUE))\n\ncor(lidarData.new[,5],ResponseV[,1])\n\nsummary(rf.fit)\n# print rf.fit\nprint(rf.fit)\n\n## Show \"importance\" of variables: higher value mean more important:\nround(importance(rf.fit), 2)\nvarImpPlot(rf.fit)\n\n## prediction rf.fit10\n(predV=predict(rf.fit, lidarData.new))\nsummary(predV)\n\n# rmse  \nrequire(hydroGOF)\ncor(ResponseV,predV)\nrmse(ResponseV[,1],predV)\nrmseR<-(rmse(ResponseV[,1],predV)/mean(ResponseV[,1]))*100 ;rmseR\n(MBE <- mean(predV) - mean(ResponseV))\n\n## r2\nlibrary(miscTools)\n(r2.10 <- rSquared(ResponseV[,1], ResponseV[,1] - predV))\n(mse <- mean((ResponseV - predV)^2))\n\n# plot\nrequire(equivalence)\nequivalence.xyplot(ResponseV[,1] ~ predV,\n                   alpha=0.05, b0.ii=0.25, b1.ii=0.25, ylim=c(0,max(ResponseV)*1.2), \n                   xlim=c(0,max(ResponseV)*1.2),main=\"\" ,type=\"p\",lwd=5, pch=50, \n                   xlab=\"Volume comercial predito - RF (m3/ha)\", ylab=\"Volume comercial observado (m3/ha)\")\n\ny<-ResponseV\nx<-lidarData.new[,varSelected]\n\nrequire(yaImpute)\nk=1\neuc=yai(x=x, y=y, method=\"euclidean\", k=k, ann=F)\ngnn=yai(x=x, y=y, method=\"gnn\", k=k, ann=F)\nmal=yai(x=x, y=y, method=\"mahalanobis\", k=k, ann=F)\nmsn=yai(x=x, y=y, method=\"msn\", k=k, ann=F)\nmsn2=yai(x=x, y=y, method=\"msn2\", k=k, ann=F)\nrf=yai(x=x, y=y, method=\"randomForest\", k=k, ann=F)\n\n# the results can be plotted.\nwindows()\nplot(euc,vars=yvars(euc))\nplot(gnn,vars=yvars(gnn))\nplot(mal,vars=yvars(mal))\nplot(msn,vars=yvars(msn))\nplot(msn2,vars=yvars(msn2))\nplot(rf,vars=yvars(rf))\n\n#rmsd\nrmsd.yai(impute.yai(rf,newdata=testing[,-c(1:3)],method=\"closest\",observed=TRUE),scale=F)\n\n#\nrforig <- impute(rf,ancillaryData=y)\nhead(rforig)\npred<-predict(rf,y)\n\nrequire(hydroGOF)\nrmse(rforig[,1],rforig[,4])\n\npred$comercial.o<-testing$comercial\npred$total.o<-testing$total\npred$celulose.o<-testing$celulose\n\nrequire(hydroGOF)\ncor(rforig[,1],rforig[,4])\nrmse(rforig[,1],rforig[,4])\nrmseR<-(rmse(rforig[,1],rforig[,4])/mean(rforig[,1]))*100 ;rmseR\n(MBE <- mean(predV) - mean(ResponseV))\n\n\n# cross validation - leave-one-out\nnewData10<-cbind(AGC,mydata10.new)\n\nV.resid=data.frame()        # Must create a vector for the calculated residuals\nV.fitted=data.frame()       # Also create a vector for the independent predictions\n\nfor (i in 1:nrow(y)) {\n  cross=yai(x=x[-i,], y=y[-i,], method=\"randomForest\", k=k, ann=F)\n  V.est<-predict(cross,x[i,])[1:3]\n  resid=cbind(y[i,][1]-V.est[1],y[i,][2]-V.est[2],y[i,][3]-V.est[3])\n  V.resid=rbind(V.resid,resid)\n  V.fitted=rbind(V.fitted,V.est)\n}\n\nrequire(hydroGOF)\ncor(V.fitted[,1],ResponseV[,1]/ResponseV[,2])\nMBE <- mean(AGC10.fitted) - mean(AGC)\n(rmse10<-rmse(V.fitted[,1],ResponseV[,1]))\nrmseR<-(rmse(V.fitted[,1],ResponseV[,1])/mean(ResponseV[,1]))*100 ;rmseR\n\n\nplotSelfValidation = function(model, actual, predicted, rmsdLoc=NULL, Title=NULL, x_axis=NULL, y_axis=NULL)\n{\n  par(oma=(c(0,1,0,0))) #increases the left margin by 1 line\n  par(mgp=(c(2.5,1,0))) #determines where the axis labels are in relation to the axis\n  maxValue = ifelse(max(predicted)>= max(actual), max(predicted), max(actual))\n  plot(predicted, actual, main=Title, xlab=x_axis, ylab=y_axis, cex.lab=1.5, cex.main=1.5,\n       xlim=c(0,maxValue), ylim=c(0,maxValue), col=\"white\", cex=1.3)\n  z=lm(formula =  actual ~ predicted,)\n  a=predict(z, interval=\"confidence\")\n  a=a[order(a[,1]),]\n  predicted_sort=sort(predicted) \n  xx= c(predicted_sort,sort(predicted_sort, decreasing = TRUE))\n  yy= c(a[,2], sort(a[,3], decreasing = TRUE))\n  polygon(xx,yy, col = \"grey75\", border = NA) #draw 95%CI\n  abline(0,1, lty=5, lwd=2, col=\"red\") #1:1 line\n  abline(z, lwd=2, col=\"black\")   #best fit line\n  text(0, 0.82*maxValue, labels = paste(\"y = \", round(z$coefficients[2],2), \" x + \", round(z$coefficients[1],2)), adj =0, cex=1.3)\n  text(0, 0.77*maxValue, labels = expression(paste(R^2)), adj =0, cex=1.3)       #first part of r-squared\n  text(0.045*maxValue, 0.76*maxValue, labels = paste(\" =\", round(summary(z)$adj.r.squared,2)), adj =0, cex=1.3) #second part of r-squared\n  text(0, 0.71*maxValue, labels = paste(\"MBE = \", round(mean(predicted) - mean(actual),0)), adj =0, cex=1.3)\n  text(maxValue, 0.1*maxValue, labels = paste(\"RMSD = \", round(rmsd(imp)[rmsdLoc,1],1)), adj =1, cex=1.3)\n  text(maxValue, 0.05*maxValue, labels = paste(\"RMSD Normalized Mean = \", round(rmsd(imp)[rmsdLoc,1]/mean(actual) * 100, 1), \"%\"), adj=1, cex=1.3)\n  text(maxValue, 0, labels = paste(\"RMSD Normalized Range = \", round(rmsd(imp)[rmsdLoc,1]/(max(actual) - min(actual)) * 100, 1), \"%\"), adj=1, cex=1.3)\n  \n  if(!is.element(rownames(rmsd(imp))[rmsdLoc],vars(model)$yvars)) text(0, 0.70*maxValue,labels = \"Imputed as Ancillary Variable\", adj=0, cex=1.3)\n  \n  \n  points(predicted, actual) #replots the points so they are on top\n  legend(x=-0.03*maxValue, y=1.00*maxValue, legend=\"Line of best fit\", lty = 1, lwd=2, col=\"black\", bty=\"n\", cex=1.3) #linear regression\n  legend(x=-0.03*maxValue, y=0.94*maxValue, legend=\"1:1 Line\", lty = 5, lwd=2, col=\"red\", bty=\"n\", cex=1.3) #1:1 line\n}\n\n\n\n#example\n\n#----- PREF_2011 -----\nimp=rforig\nrmsd(imp)\nwindows()\nplotSelfValidation(rf, pred[,1],pred[,4], rmsdLoc=1, Title=\"Tree Height validation\", x_axis=\"Imputed Ht (m)\",y_axis=\" Observed Ht (m)\" )\nplotSelfValidation(rf, pred[,2],pred[,5], rmsdLoc=2, Title=\"Tree Height validation\", x_axis=\"Imputed Ht (m)\",y_axis=\" Observed Ht (m)\" )\nplotSelfValidation(rf, pred[,3],pred[,6], rmsdLoc=3, Title=\"Tree Height validation\", x_axis=\"Imputed Ht (m)\",y_axis=\" Observed Ht (m)\" )\n\nplotSelfValidation(rf, rforig[,1],rforig[,4], rmsdLoc=1, Title=\"Tree basal area (BA) validation\",x_axis=\"Imputed BA (m2/tree)\",y_axis=\" Observed BA (m2/tree)\" )\nplotSelfValidation(rf, rforig[,2],rforig[,5], rmsdLoc=1, Title=\"Tree basal area (BA) validation\",x_axis=\"Imputed BA (m2/tree)\",y_axis=\" Observed BA (m2/tree)\" )\nplotSelfValidation(rf, rforig[,3],rforig[,6], rmsdLoc=1, Title=\"Tree basal area (BA) validation\",x_axis=\"Imputed BA (m2/tree)\",y_axis=\" Observed BA (m2/tree)\" )\n",
    "created" : 1422415298534.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1777661953",
    "id" : "E5E00EDC",
    "lastKnownWriteTime" : 1421828085,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled26"
    },
    "source_on_save" : false,
    "type" : "r_source"
}
{
    "contents" : "# Author: Remko Duursma. Uses code by Remko Duursma in Maeswrap package, see Plotstand.\ncoord3dshapeTree <- function(crownshape=c(\"cone\",\"ellipsoid\",\"halfellipsoid\",\"paraboloid\",\"cylinder\"),\n                         nz=5, nalpha=5, CL=1, CW=1, x0=0, y0=0, z0=0\n){\n  \n  crownshape <- match.arg(crownshape)\n  \n  z <- rep(seq(0,1,length=nz),each=nalpha)\n  angs <- rep(seq(0,2*pi, length=nalpha),nz)\n  \n  if(crownshape == \"cone\")distfun <- (1-z)\n  if(crownshape == \"ellipsoid\")distfun <- sqrt(1 - ((z-1/2)^2)/((1/2)^2))\n  if(crownshape == \"halfellipsoid\")distfun <- sqrt(1 - z**2)\n  if(crownshape == \"paraboloid\")distfun <- sqrt(1-z)\n  if(crownshape == \"cylinder\")distfun <- 1\n  \n  \n  r <- CW/2\n  x <- x0 + r*distfun*cos(angs)\n  y <- y0 + r*distfun*sin(angs)\n  z <- z0 + z*CL\n  \n  keep <- !duplicated(cbind(x,y,z))\n  x <- x[keep]\n  y <- y[keep]\n  z <- z[keep]\n  \n  OutMatrix<-jitter(matrix(cbind(x,y,z),ncol=3), factor = 50)\n  return(OutMatrix)\n \n}\n\n??rLiDAR\nTree1<-coord3dshapeTree(\"cone\",nz=50, nalpha=50, CL=1, CW=0.5, x0=0, y0=0, z0=0)\n\nrequire(rgl)\nplot3d(Tree1)\n??jitter\naa=jitter(Tree1, factor = 50)\nplot3d(aa)\n\n# Set the dimensions of the displayed forest stand\nxlength<-30 # x length\nylength<-20 # y length\n\n# Set the space between trees\nsx<-3 # x space length\nsy<-2 # y space length\n\n# Tree location grid\nXYgrid <- expand.grid(x = seq(1,xlength,sx), y = seq(1,ylength,sy))\n\n# Get the number of trees\nNtrees<-nrow(XYgrid)\n\n# Plot a virtual Eucalyptus forest plantation stand using the halfellipsoid tree crown shape\n\n# Set stand trees parameters\nmeanHCB<-5  # mean of the height at canopy base\nsdHCB<-1.5  # standard deviation of the height at canopy base\nHCB<-rnorm(Ntrees, mean=meanHCB, sd=sdHCB) # height at canopy base\nCL<-HCB     # tree crown height\nCW<-HCB*0.6 # tree crown diameter\n\nopen3d()    # open a rgl window\n\n# Plotting the stand\nTreeList<-data.frame()\nfor( i in 1:Ntrees){\n  TreesRun<-coord3dshapeTree(crownshape = \"cone\", nz=50,nalpha=50,CL = CL[i], CW = CW[i],\n               z0 = HCB[i], x0 = XYgrid[i,1], y0 = XYgrid[i,2])\n  TreeList<-rbind(TreeList,cbind(TreesRun,ID=rep(i,nrow(TreesRun))))\n  \n}\nhead(TreeList)\nplot3d(TreeList, col=TreeList[,4])\ncolnames(TreeList)<-c(\"x\",\"y\",\"z\",\"id\")\n\ndf<-TreeList\nhead(df)\n\"cone\",nz=50, nalpha=50, CL=1, CW=0.5, x0=0, y0=0, z0=0)\n\n\nar<-range(aa[,1])[2]-range(aa[,1])[1]\n\nrequire(sp)\npoints <- SpatialPoints(df)\npixels <- SpatialPixelsDataFrame(points, tolerance = 0.916421, points@data)\nraster <- raster(pixels[,'z'])\n\n\n\ns100 <- matrix(c(267573.9, 2633781, 213.29545, 262224.4, 2633781, 69.78261, 263742.7, 2633781, 51.21951, 259328.4, 2633781, 301.98413, 264109.8, 2633781, 141.72414, 255094.8, 2633781, 88.90244),  ncol=3,  byrow=TRUE)\ncolnames(s100) <- c('X', 'Y', 'Z')\n\nlibrary(raster)\n# set up an 'empty' raster, here via an extent object derived from your data\ne <- extent(df[,1:2])\ne <- e + 1 # add this as all y's are the same\nxg<-e[2]-e[1]\nyg<-e[4]-e[3]\n\nr <- raster(e, ncol=xg/0.15, nrow=yg/0.15)\n# or r <- raster(xmn=, xmx=,  ...\n\n# you need to provide a function 'fun' for when there are multiple points per cell\nx <- rasterize(df[, 1:2], r, df[,3], fun=mean)\nplot(x)\n??plot3D\nrequire(rasterVis)\nplot3D(x)\n\n??rLiDAR\nrequire(rLiDAR)\n# Setting the fws:\nfws<-5 # dimention 5x5\n\n# Setting the specified height above ground for detectionbreak\nminht<-1.37\n\n# Getting the individual tree detection list\ntreeList<-singleTreeCHM(x, fws, minht)\nsummary(treeList)\nwindows()\nplot(x)\n\nplot(SpatialPoints(treeList), add=T)\n",
    "created" : 1422391581060.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3528924016",
    "id" : "6ADE715B",
    "lastKnownWriteTime" : 1422414127,
    "path" : "~/00_PUBLICACAO/simulateTrees.r",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled26"
    },
    "source_on_save" : false,
    "type" : "r_source"
}
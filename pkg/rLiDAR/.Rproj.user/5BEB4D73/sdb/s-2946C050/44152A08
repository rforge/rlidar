{
    "contents" : "###--------------------------------------------------------------------------------------------------------###\n#----------------------------------------------------------------------------------------------------------###\n# SILVA, C. A. (2013)                                                                                      ###\n# Forester and Master's degree                                                                             ### \n# Ph.D Student at University of Idaho                                                                      ###\n# Rocky Mountain Reserach Station- RMRS                                                                    ###\n# US Forest Service - USDA                                                                                 ###\n# Moscow - Idaho                                                                                           ###\n# carlos_engflorestal@outlook.com.br                                                                       ###\n# Skype: flowds                                                                                            ###\n#----------------------------------------------------------------------------------------------------------###\n\n##############################################################################################################\n#------------------------------ Klabin - LiDAR  project -----------------------------------------------------#\n#               This script is used to stand volume modeling using LiDAR metrics\n#                                           Subset: Eucalyptus spp.\n##############################################################################################################\n\n#----------------------------------------------------------------------------------------------------------###\n# 1 set a workspace\n#----------------------------------------------------------------------------------------------------------###\ndir<-\"C:\\\\08_Pinus_sp_PTA\"\nsetwd(dir)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 2. Load lidar plot data\n#----------------------------------------------------------------------------------------------------------###\nlidarData <- read.csv(file=paste0(dir,\"\\\\01_inputdata\\\\LiDAR_sp_PTA.csv\"), sep=\",\", header=TRUE)\ncolnames(lidarData) # columms names\nhead(lidarData)\nnrow(lidarData)\nhead(lidarData)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 3. Explore relationships between stand volume and LiDAR predictor variables\n#----------------------------------------------------------------------------------------------------------###\n#3.1 Response variable\nhist(lidarData$total)\nlidarData<-subset(lidarData,lidarData$total<=30)\nlidarData<-subset(lidarData,lidarData$Elev.maximum<20)\nResponseV <- (lidarData$total * 10000)/lidarData$plotarea\nhist(ResponseV)\nhist(ResponseV, prob=T, main=\"Probability Density distribution of the Volume total\", col='gray',\n     breaks='fd',xlim=c(0,max(ResponseV)*1.1),\n     ylim=c(0,max(density(ResponseV)$y)*1.2),\n     xlab=\"Volume total (m3/ha)\")\n#Next I'll add the mean and median as vertical lines using abline()\nlines(density(ResponseV), lwd=1, lty='solid', col='red')\nabline(v=mean(ResponseV), lwd=1, lty='dotted', col='blue')\nabline(v=mean(ResponseV)+sd(ResponseV), lwd=1, lty='dotted', col='red')\nabline(v=mean(ResponseV)-sd(ResponseV), lwd=1, lty='dotted', col='yellow')\nabline(v=median(ResponseV), lwd=1, lty='twodash', col='green')\n#Last, I'll add a legend to keep track of all these lines.\nlegend(x='topright', c( 'Mean',\"+ 1sd\",\"- 1sd\", 'Median', \"density\"), col=c('blue',\"red\",\"yellow\", 'green', 'red'),\n       lwd=c(1, 1), lty=c('dotted','dotted','dotted', 'twodash','solid'), bty=\"n\")\nsummary(ResponseV) # summary\nVarResponseV<-var(ResponseV);VarResponseV # get the variance\nSdResponseV<-sd(ResponseV);SdResponseV # get the stand deviation\n#----------------------------------------------------------------------------------------------------------###\n#----------------------------------------------------------------------------------------------------------###\n#3.2 LiDAR metrics\nKeepMetrics<-c(\"Elev.maximum\",\"Elev.mean\",\"Elev.mode\",\"Elev.stddev\",\"Elev.variance\",\"Elev.CV\",\"Elev.IQ\",\"Elev.skewness\",\"Elev.kurtosis\",\n               \"Elev.P01\",\"Elev.P05\",\"Elev.P10\",\"Elev.P20\",\"Elev.P25\",\"Elev.P30\",\"Elev.P40\",\"Elev.P50\",\"Elev.P60\",\"Elev.P70\",\"Elev.P75\",\n               \"Elev.P80\",\"Elev.P90\",\"Elev.P95\",\"Elev.P99\",\"Percentage.first.returns.above.1.37\")\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 4. Explore accessing variables and subsetting\n#----------------------------------------------------------------------------------------------------------###\nlidarData<-cbind(ResponseV,lidarData[,KeepMetrics])\ncolnames(lidarData) # columms names\nncol(lidarData) # numeric of the columms\nrownames(lidarData) # row names\nnrow(lidarData) # numeric of the rows\nplot(lidarData$Elev.maximum, ResponseV )\ncor(lidarData$Elev.maximum, ResponseV)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 5. Generate a correlation matrix\n#----------------------------------------------------------------------------------------------------------###\ncorLidarData<-lidarData[,-1]\ncorrMat <- cor(corLidarData)\nprint(corrMat)\n\n# remove the variables high correlated ( cor > 0.90)\ncorrMat[upper.tri(corrMat)] <- 0\ndiag(corrMat) <- 0\nlidarData.new <- corLidarData[, apply(corrMat,2,function(x) all(x<=0.90))]\nhead(lidarData.new)\ncorrMat <- cor(lidarData.new);print(corrMat) # new correlation to check \n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 6. LiDAR Modeling\n#----------------------------------------------------------------------------------------------------------###\n#----------------------------------------------------------------------------------------------------------###\n#  6.1 Variable Selection\n#----------------------------------------------------------------------------------------------------------###\n# require package\nrequire(randomForest)\n\n# source var. selection function : \nsource(\"C:\\\\Users\\\\Carlos\\\\Documents\\\\PhD_UIdaho\\\\01_Classes\\\\FOR504_02_STComputational_Data_Analysis\\\\Assignments\\\\Assignment5\\\\rf.modelSel.R\")\n\n# find the best variables\nvarsSelec<-data.frame()\nfor ( i in 1:100) {\n  ( rf.regress <- rf.modelSel(lidarData.new, ResponseV, parsimony=0.03) )\n  IV<-cbind(rownames(rf.regress$IMPORTANCE[1]),rf.regress$IMPORTANCE[[1]])\n  varsSelec<-rbind(varsSelec,IV)\n}\n\nnV<-tapply(as.numeric(paste0(varsSelec[,2])),paste0(varsSelec[,1]),length)\nMIR=tapply(as.numeric(paste0(varsSelec[,2])),paste0(varsSelec[,1]),mean)\n\nvarSelected<-c(\"Elev.P99\",\"Elev.CV\")\n\nset.seed(1)\n#( rf.fit <- randomForest(ResponseV~lidarData.new[,varSelected][,1],importance=TRUE, mtry=1,na.action=na.omit,ntree=1000,keep.forest=TRUE))\n\n(rf.fit <- randomForest(x=lidarData.new, y=ResponseV,importance=TRUE, ntree=1000))\n\nsummary(rf.fit)\n# print rf.fit\nprint(rf.fit)\n\n## Show \"importance\" of variables: higher value mean more important:\nround(importance(rf.fit), 2)\nvarImpPlot(rf.fit)\n\n# get the tree\ngetTree(rf.fit, 1, labelVar=TRUE)\n\n## prediction rf.fit10\n(predV=predict(rf.fit, lidarData.new[,varSelected]))\nsummary(predV)\n\n# rmse  \nrequire(hydroGOF)\ncor(ResponseV,predV)\nrmse(ResponseV,predV)\nrmseR<-(rmse(ResponseV,predV)/mean(ResponseV))*100 ;rmseR\n(MBE <- mean(predV) - mean(ResponseV))\n\n## r2\nlibrary(miscTools)\n(r2.10 <- rSquared(ResponseV, ResponseV - predV))\n(mse <- mean((ResponseV - predV)^2))\n\n# plot\nrequire(equivalence)\nequivalence.xyplot(ResponseV ~ predV,\n                   alpha=0.05, b0.ii=0.25, b1.ii=0.25, ylim=c(0,max(ResponseV)*1.2), \n                   xlim=c(0,max(ResponseV)*1.2),main=\"\" ,type=\"p\",lwd=5, pch=50, \n                   xlab=\"Volume total predito - RF (m3/ha)\", ylab=\"Volume total observado (m3/ha)\")\n\n\n# cross validation - leave-one-out\ninputCross<-cbind(ResponseV,lidarData.new)\n\nResponseV.resid=numeric(length=nrow(inputCross))        # Must create a vector for the calculated residuals\nResponseV.fitted=numeric(length=nrow(inputCross))       # Also create a vector for the independent predictions\n\nfor (i in 1:nrow(inputCross)) {\n  cross=randomForest(x=inputCross[-i,varSelected], y=inputCross[-i,\"ResponseV\"],importance=TRUE, na.action=na.omit)\n  ResponseV.est=predict(cross, inputCross[i,])     # The estimate for each plot in the loop\n  ResponseV.resid[i]=inputCross$ResponseV[i]-ResponseV.est\n  ResponseV.fitted[i]=ResponseV.est \n}\n\nrequire(hydroGOF)\ncor(ResponseV,ResponseV.fitted)\nMBE <- mean(ResponseV.fitted) - mean(ResponseV)\n(rmse<-rmse(ResponseV,ResponseV.fitted))\nrmseR<-(rmse(ResponseV,ResponseV.fitted)/mean(ResponseV))*100; rmseR\n\n# equivalence plot to cross validation\n#install.packages(\"equivalence\")\nrequire(equivalence)\nequivalence.xyplot(ResponseV ~ ResponseV.fitted,\n                   alpha=0.05, b0.ii=0.25, b1.ii=0.25, ylim=c(0,max(ResponseV)*1.2), \n                   xlim=c(0,max(ResponseV)*1.2),main=\"Validacao cruzada\" ,type=\"p\",lwd=5, pch=50, \n                   xlab=\"Volume total predito - validacao (m3/ha)\", ylab=\"Volume total observado (m3/ha)\")\n\n\n#----------------------------------------------------------------------------------------------------------###\n# 6.2 Appling the model to the landscape                                                                   #\n#----------------------------------------------------------------------------------------------------------###\n\n# ResponseV map create across the landscape\n#install.packages(\"yaImpute\")\n#install.packages(\"sp\")\nrequire(yaImpute)\nrequire(sp)\nLon = NULL\nLat = NULL\nRows = NULL\nCols = NULL\nNodata = -9999\nMyPredFunc = NULL\npredlist = list(Elev.P99=\"H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\03_RSdata\\\\00_LiDAR\\\\MA02BMR_mirandinha\\\\PROCESSING\\\\09_LTKprocessor_MA02BMR_mirandinha\\\\lyers\\\\Metrics\\\\Elev_P99_5METERS.asc\",\n                Elev.CV=\"H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\03_RSdata\\\\00_LiDAR\\\\MA02BMR_mirandinha\\\\PROCESSING\\\\09_LTKprocessor_MA02BMR_mirandinha\\\\lyers\\\\Metrics\\\\ElevCV_5METERS.asc\")\n\n\nXTypes = list(Elev.99=\"numeric\",Elev.CV=\"numeric\")\n\noutlist = list(predict=\"H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\04_Projects\\\\00_Modelagem_stand\\\\08_Pinus_sp_PTA\\\\05_modeling\\\\MA02BMR_mirandinha_Vt.asc\")\nAsciiGridPredict(rf.fit, predlist, outlist, xyptes = XTypes, lon = Lon, lat = Lat, rows = Rows, cols = Cols, nodata = Nodata, myPredFunc = MyPredFunc)\noutgrid = read.asciigrid(\"H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\04_Projects\\\\00_Modelagem_stand\\\\08_Pinus_sp_PTA\\\\05_modeling\\\\MA02BMR_mirandinha_Vt.asc\")\n\n# Packages necessary\nrequire(raster);require(sp);require(maptools);\n# Importing shapefile of the land\n# open the shapefile\nforest.shp <- readShapePoly('H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\04_Projects\\\\00_Modelagem_stand\\\\08_Pinus_sp_PTA\\\\01_inputdata\\\\shape_stand\\\\Pinus_stand.shp')\n\n# visualization of the original ResponseV map\nimage(outgrid, col=gray(0:255/255))\nplot(forest.shp, add=T, border='red', bg='transparent', asp=1)\n\n# clip the area of the interest\noutgrid_stand <- outgrid[!is.na(overlay(outgrid, forest.shp)),]\n\n# plot general ResponseV map cliped\nimage(outgrid_stand, col=gray(0:255/255),axes = T)\nplot(forest.shp, add=T, border='red', bg='transparent', asp=1)\n\nspplot(outgrid_stand, col.regions=bpy.colors(64), scale=list(draw=T),\n       sp.layout=list(list(\"sp.polygons\", forest.shp)))\n\n# save the map \nwriteAsciiGrid(outgrid_stand,\"H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\04_Projects\\\\00_Modelagem_stand\\\\08_Pinus_sp_PTA\\\\05_modeling\\\\MA02BMR_mirandinha_Vt_Stand.asc\")\n\n#----------------------------------------------------------------------------------------------------------###\n# 6.3 Computing the stock of volume in the stand                                                                   #\n#----------------------------------------------------------------------------------------------------------###\nStandRaster<-raster(\"H:\\\\00_LiDAR\\\\00_LiDAR_projetos\\\\00_Klabin\\\\04_Projects\\\\00_Modelagem_stand\\\\08_Pinus_sp_PTA\\\\05_modeling\\\\MA02BMR_mirandinha_Vt_Stand.asc\")\nplot(StandRaster)\nStandDF=as.data.frame(StandRaster, row.names=NULL, xy=TRUE,na.rm=TRUE)\n\n# mean approch\nmeanV<-mean(StandDF[,3])\nStandVolume1<-(forest.shp@data$area/10000)*meanV\n\n# pixel approch\nStandDF[,4]<-(StandDF[,3]*25)/10000\ncolnames(StandDF)<-c(\"x\",\"y\",\"Vt.ha\",\"Vt.25\")\nhead(StandDF)\nStandVolume2<-sum(StandDF[,4])\n\n\n",
    "created" : 1421612680592.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "188276957",
    "id" : "44152A08",
    "lastKnownWriteTime" : 1420257893,
    "path" : "C:/08_Pinus_sp_PTA/04_script/Klabin_RScrip_sp_PTA_vt.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}
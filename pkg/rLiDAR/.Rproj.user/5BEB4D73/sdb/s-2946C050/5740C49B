{
    "contents" : "\n#----------------------------------------------------------------------------------------------------------###\n# 1 set a workspace\n#----------------------------------------------------------------------------------------------------------###\ndir<-\"C:\\\\08_Pinus_sp_PTA\"\nsetwd(dir)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 2. Load lidar plot data\n#----------------------------------------------------------------------------------------------------------###\nlidarData <- read.csv(file=paste0(dir,\"\\\\01_inputdata\\\\LiDAR_sp_PTA.csv\"), sep=\",\", header=TRUE)\ncolnames(lidarData) # columms names\nhead(lidarData)\nnrow(lidarData)\nhead(lidarData)\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 3. Explore relationships between stand volume and LiDAR predictor variables\n#----------------------------------------------------------------------------------------------------------###\n#3.1 Response variable\nhist(lidarData$total)\nlidarData<-subset(lidarData,lidarData$total<=30)\nlidarData<-subset(lidarData,lidarData$Elev.maximum<20)\n#ResponseV <- (lidarData$total * 10000)/lidarData$plotarea\n#hist(ResponseV)\n\n#----------------------------------------------------------------------------------------------------------###\n#3.2 LiDAR metrics\nKeepMetrics<-c(\"Elev.maximum\",\"Elev.mean\",\"Elev.mode\",\"Elev.stddev\",\"Elev.variance\",\"Elev.CV\",\"Elev.IQ\",\"Elev.skewness\",\"Elev.kurtosis\",\n               \"Elev.P01\",\"Elev.P05\",\"Elev.P10\",\"Elev.P20\",\"Elev.P25\",\"Elev.P30\",\"Elev.P40\",\"Elev.P50\",\"Elev.P60\",\"Elev.P70\",\"Elev.P75\",\n               \"Elev.P80\",\"Elev.P90\",\"Elev.P95\",\"Elev.P99\",\"Percentage.first.returns.above.1.37\")\n#----------------------------------------------------------------------------------------------------------###\n\n#----------------------------------------------------------------------------------------------------------###\n# 4. Explore accessing variables and subsetting\n#----------------------------------------------------------------------------------------------------------###\nResponseV<-lidarData[,c(\"comercial\",\"total\",\"celulose\")]\n\nlidarData<-cbind(ResponseV,lidarData[,KeepMetrics])\ncolnames(lidarData) # columms names\nncol(lidarData) # numeric of the columms\nrownames(lidarData) # row names\nnrow(lidarData) # numeric of the rows\nplot(lidarData$Elev.maximum, ResponseV )\ncor(lidarData$Elev.maximum, ResponseV)\n\ncorLidarData<-lidarData[,-1]\ncorrMat <- cor(corLidarData)\nprint(corrMat)\n\n# remove the variables high correlated ( cor > 0.90)\ncorrMat[upper.tri(corrMat)] <- 0\ndiag(corrMat) <- 0\nlidarData.new <- corLidarData[, apply(corrMat,2,function(x) all(x<=0.90))]\nhead(lidarData.new)\ncorrMat <- cor(lidarData.new);print(corrMat) # new correlation to check \n\n\nrequire (yaImpute)\n\ny<-lidarData[,c(\"comercial\",\"total\",\"celulose\")]\ny <- (y * 10000)/lidarData$plotarea\n\n#x<-lidarData[,KeepMetrics]\nx<-lidarData[,c(\"Elev.P99\",\"Elev.CV\")]\n\n\n\n#install.packages(\"vegan\")\n#require(vegan)\nk=1\neuc=yai(x=x, y=y, method=\"euclidean\", k=k, ann=F)\ngnn=yai(x=x, y=y, method=\"gnn\", k=k, ann=F)\nmal=yai(x=x, y=y, method=\"mahalanobis\", k=k, ann=F)\nmsn=yai(x=x, y=y, method=\"msn\", k=k, ann=F)\nmsn2=yai(x=x, y=y, method=\"msn2\", k=k, ann=F)\nrf=yai(x=x, y=y, method=\"randomForest\", k=k, ann=F)\n\n# the results can be plotted.\nplot(euc,vars=yvars(euc))\nplot(gnn,vars=yvars(gnn))\nplot(mal,vars=yvars(mal))\nplot(msn,vars=yvars(msn))\nplot(msn2,vars=yvars(msn2))\nplot(rf,vars=yvars(rf))\n\n#rmsd\nrmsd.yai(impute.yai(rf,newdata=y,method=\"closest\",observed=TRUE),scale=T)\n\n#\nrforig <- impute(rf,ancillaryData=y)\n\n\nrmsd(rf)\n# compare these results using the generalized mean distances..\ngrmsd(mal,gnn,msn)\nplot(compare.yai(euc,gnn,mal,msn,msn2,rf))\n\nsummary(rf)\n\n\n## prediction rf.fit10\n(predV=predict(rf, ))\nsummary(predV)\n\n# rmse  \nrequire(hydroGOF)\ncor(rforig[,1],rforig[,4])\nrmse(rforig[,1],rforig[,4])\nrmseR<-(rmse(rforig[,1],rforig[,4])/mean(rforig[,1]))*100 ;rmseR\n(MBE <- mean(predV) - mean(ResponseV))\n\n## r2\nlibrary(miscTools)\n(r2.10 <- rSquared(rforig[,1], rforig[,1] - rforig[,4]))\n(mse <- mean((rforig[,1] - rforig[,4])^2))\n\n\nrequire(equivalence)\nequivalence.xyplot(rforig[,1] ~ rforig[,4],\n                   alpha=0.05, b0.ii=0.25, b1.ii=0.25, ylim=c(0,max(rforig[,1])*1.2), \n                   xlim=c(0,max(rforig[,1])*1.2),main=\"\" ,type=\"p\",lwd=5, pch=50, \n                   xlab=\"Volume total predito - RF (m3/ha)\", ylab=\"Volume total observado (m3/ha)\")\n\n\n# reduce the plant community data for randomForest.\nybaB <- whatsMax(y,nbig=7)  # see help on whatsMax\n\n\n# ResponseV map create across the landscape\n#install.packages(\"yaImpute\")\n#install.packages(\"sp\")\nrequire(yaImpute)\nrequire(sp)\nLon = NULL\nLat = NULL\nRows = NULL\nCols = NULL\nNodata = -9999\nMyPredFunc = NULL\npredlist = list(Elev.P99=\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\09_LTKprocessor_MA02BMR_mirandinha\\\\lyers\\\\Metrics\\\\Elev_P99_5METERS.asc\",\n                Elev.CV=\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\09_LTKprocessor_MA02BMR_mirandinha\\\\lyers\\\\Metrics\\\\ElevCV_5METERS.asc\")\n\n\nXTypes = list(Elev.99=\"numeric\",Elev.CV=\"numeric\")\n\noutlist = list(comercial=\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\MA02BMR_mirandinha_Vc.asc\",\n               total=\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\MA02BMR_mirandinha_Vt.asc\",\n               celulose=\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\MA02BMR_mirandinha_Vcl.asc\")\nAsciiGridPredict(rf, predlist, outlist, xyptes = XTypes, lon = Lon, lat = Lat, rows = Rows, cols = Cols, nodata = Nodata, myPredFunc = MyPredFunc)\noutgrid = read.asciigrid(\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\MA02BMR_mirandinha_Vt.asc\")\n\nclass(outgrid)\n\n# Packages necessary\nrequire(raster);require(sp);require(maptools);\n# Importing shapefile of the land\n# open the shapefile\nforest.shp <- readShapePoly('C:\\\\Users\\\\Carlos\\\\Dropbox\\\\00_LiDAR_Klabin\\\\Arquivos_VolumeTotal\\\\shape_stand\\\\Pinus_stand.shp')\n\n# clip the area of the interest\noutgrid_stand <- outgrid[!is.na(overlay(outgrid, forest.shp)),]\n\n# save the map \nwriteAsciiGrid(outgrid_stand,\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\MA02BMR_mirandinha_Vt_Stand.asc\")\n\n#----------------------------------------------------------------------------------------------------------###\n# 6.3 Computing the stock of volume in the stand                                                                   #\n#----------------------------------------------------------------------------------------------------------###\nStandRaster<-raster(\"C:\\\\Klabin\\\\LTK_processor_Klabin\\\\MA02BMR_mirandinha_Vt_Stand.asc\")\nclass(StandRaster)\nplot(StandRaster)\nStandDF=as.data.frame(StandRaster, row.names=NULL, xy=TRUE,na.rm=TRUE)\n\n# mean approch\nmeanV<-mean(StandDF[,3])\nStandVolume1<-(forest.shp@data$area/10000)*meanV\n\n# pixel approch\nStandDF[,4]<-(StandDF[,3]*25)/10000\ncolnames(StandDF)<-c(\"x\",\"y\",\"Vt.ha\",\"Vt.25\")\nhead(StandDF)\nStandVolume2<-sum(StandDF[,4])\n\n",
    "created" : 1421612613180.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1318721761",
    "id" : "5740C49B",
    "lastKnownWriteTime" : 1421828085,
    "path" : "C:/08_Pinus_sp_PTA/imputation.r",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled23"
    },
    "source_on_save" : false,
    "type" : "r_source"
}
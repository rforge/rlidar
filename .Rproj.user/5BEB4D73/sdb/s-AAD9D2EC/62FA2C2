{
    "contents" : "#'LiDAR individual tree canopy area \n#'\n#'@description Compute and export individual tree canopy area detected on the LiDAR-derived Canopy Height Model (CHM) \n#'\n#'@usage ForestCAS(chm,loc,maxcrown,exclusion)\n#'\n#'@param chm A LiDAR-derived Canopy Height Model (CHM)\n#'@param loc A dataframe of the individual tree location and height (x,y and height) \n#'@param maxcrown Maximum individual tree crown radius expected. Default 10.0 m\n#'@param exclusion Exclusion of the pixels that has values below the percent of maximum tree height. Default is 0.3 \n#'@return returns Individual tree canopy boundary [[1]] and list of canopy area [[2]] \n#'@author Carlos Alberto Silva\n#'@examples\n#'\n#'\n#'\\dontrun{\n#'\n#'#' Importing the LiDAR-derived CHM file\n#'data(chm) # or set a CHM. e.g. chm<-readGDAL(\"CHM_stand.asc\") \n#'\n#'#' Set the loc parameter\n#'sCHM<-CHMsmoothing(chm, filter=\"mean\", ws=5) # smoothing CHM\n#'loc<-sTreesCHM(sCHM, fws=5,htd=8) # or import a tree list\n#'\n#'#' Set the maxcrown parameter\n#'maxcrown=10.0 \n#'\n#'#' Set the exclusion parameter\n#'exclusion=0.3 # 30%\n#'\n#'#' Compute individual tree detection canopy area\n#'canopy<-ForestCAS(chm,loc, maxcrown,exclusion)\n#'\n#'#' Getting the individual tree detection canopy area boundary\n#'boundaryTrees<-canopy[[1]]\n#\n#'#' Plotting the individual tree canopy boundary over the CHM\n#'plot(chm) # plotting CHM\n#'plot(boundaryTrees, add=T, border='red', bg='transparent', asp=1) # adding tree canopy boundary to the plot\n#'\n#'#' Getting the individual tree detection canopy area list\n#'canopyList<-canopy[[2]]\n#'summary(canopyList)\n#'plot(SpatialPoints(canopyList[,1:2]),col=\"black\", add=T, pch=\"*\") # adding tree location to the plot\n#'} \n#' @export\nForestCAS<-function(chm,loc,maxcrown=10,exclusion=0.3) {\n\n  chm<-as(chm, \"SpatialGridDataFrame\")\n  Hthreshold<-min(loc[,3])*exclusion\n  polys<-list() \n  width<-numeric()  \n  \n  for(i in 1:nrow(loc)) { \n    width[i] =maxcrown\n    discbuff<-disc(radius=width[i], centre=c(loc$x[i], loc$y[i])) \n    discpoly<-Polygon(rbind(cbind(discbuff$bdry[[1]]$x, \n                                  y=discbuff$bdry[[1]]$y), c(discbuff$bdry[[1]]$x[1], \n                                                             y=discbuff$bdry[[1]]$y[1]))) \n    polys<-c(polys, discpoly) \n  } \n  \n  spolys<-list() \n  for(i in 1:length(polys)) { \n    spolybuff<-Polygons(list(polys[[i]]), ID=row.names(loc)[i]) \n    spolys<-c(spolys, spolybuff) \n  } \n  polybuffs<-SpatialPolygons(spolys) \n\n  chmdf<-as.data.frame(chm,xy=TRUE)\n  Points.Ply<-over(SpatialPoints(chmdf[,2:3]),polybuffs) # overlay\n  Points.PlyD<-cbind(chmdf,Points.Ply) # cbind\n  Points.PlyD<-na.omit(Points.PlyD) # omite NAs\n vor =  deldir(loc[,1], loc[,2], z=loc[,3],suppressMsge=T)\n  tile = tile.list(vor)\n  polys = vector(mode='list', length=length(tile))\n  for (i in seq(along=polys)) {\n    pcrds = cbind(tile[[i]]$x, tile[[i]]$y)\n    pcrds = rbind(pcrds, pcrds[1,])\n    polys[[i]] = Polygons(list(Polygon(pcrds)), ID=as.character(i))\n  }\n  \n  SP = SpatialPolygons(polys)\n  veronoi = SpatialPolygonsDataFrame(SP, data=data.frame(x=loc[,1], \n                                                         y=loc[,2], row.names=sapply(slot(SP, 'polygons'), \n                                                                                          function(x) slot(x, 'ID'))))\n  chmV<-over(SpatialPoints(Points.PlyD[,2:3]), SP)\n  RpD<-cbind(Points.PlyD,chmV)\n  RpD.filter<-subset(RpD[,1:5],RpD[,1]>=Hthreshold)\n  RpD.filter<-cbind(RpD.filter[,1:3],RpD.filter[,5])\n  colnames(RpD.filter)<-c(\"z\",\"x\",\"y\",\"g\")\n  h.mH<-ddply(RpD.filter,.(g), function (RpD.filter)\n    subset(RpD.filter,RpD.filter[,1]>= max(RpD.filter[,1])*exclusion))\n  \n  DF2raster<-function(h.mH, i){\n    h.mHkl<-subset(h.mH,h.mH[,4]==levels(factor(h.mH[,4]))[i])\n    \n    if (nrow(h.mHkl==1)==TRUE) {\n      h.mHkl<-rbind(h.mHkl,c(h.mHkl[,1],h.mHkl[,2]+0.005,h.mHkl[,3]+0.005,h.mHkl[,4]))}\n    \n    spP <- cbind(h.mHkl[,2:3],h.mHkl[,1],h.mHkl[,4])\n    coordinates(spP)<- ~ x + y\n    suppressWarnings(gridded(spP) <- TRUE)\n    \n    rasterDF <- raster(spP)\n    hhg<- boundaries(rasterDF, type='outer') \n    p <- rasterToPolygons(hhg, dissolve=TRUE)\n    sp.polys <- p[1,]\n    return(sp.polys)}\n \n  for ( j in 1:nlevels(factor(h.mH[,4]))){\n    assign(paste0(\"SP.polys\", j), DF2raster(h.mH,j))\n    print(paste(\"computting canopy area: Tree\",j))}\n  \n  polygons <- slot(SP.polys1, \"polygons\")\n  \n  for (i in 1:nlevels(factor(h.mH[,4]))) {\n    data.loc <- get(paste0(\"SP.polys\",i))\n    polygons <- c(slot(data.loc, \"polygons\"),polygons)\n  }\n  \n  for (i in 1:length(polygons)) {\n    slot(polygons[[i]], \"ID\") <- paste(i)\n  }\n  \n  spatialPolygons <- SpatialPolygons(polygons)\n  spdf <- SpatialPolygonsDataFrame(spatialPolygons, \n                                   data.frame(Trees=1:length(polygons)))\n  \n  options(scipen=10)\n  spdf<-spdf[spdf@data[-length(polygons),],]\n  areaList<-sapply(slot(spdf, \"polygons\"), slot, \"area\")\n  canopyTable<-cbind(loc,areaList)\n  colnames(canopyTable)<-c(\"x\",\"y\",\"z\",\"ca\")\n  result=list(spdf,canopyTable) \n  return(result)\n  \n}",
    "created" : 1415679312172.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1132042066",
    "id" : "62FA2C2",
    "lastKnownWriteTime" : 1415689257,
    "path" : "~/rLiDAR/rLiDAR/R/ForestCAS.R",
    "project_path" : "R/ForestCAS.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}
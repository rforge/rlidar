{
    "contents" : "#' LiDAR - Importing and reading LAS file\n#'\n#'@description Importing and reading LAS file format. The LAS file is a public file format for the interchange of LiDAR 3-dimensional point cloud data (American Society of Photogrammetry and Remote Sensing - ASPRS)\n#'\n#'@usage readLAS(LASfile)\n#'\n#'@param LASfile A standard LAS data file\n#'@param short Return only : x, y, z, intensity and return number\n#'@return Return dataframe of the LAS data set\n#'@author Michael Sumner\n#'@examples\n#'\n#'\n#'\\dontrun{\n#'#' Importing LAS file:\n#'myLAS<-data(LASfile) # or set a LAS  file (myLAS<-\"../LASfile.las)\"\n#'\n#'#' Reading LAS file\n#'readLAS(myLAS)\n#'\n#'#' Summary of the LAS file\n#'summary(myLAS)\n#'}\n#'\n#' @export\nreadLAS <- function(LASfile, short=TRUE) {\n  skip <- 0\n  nrows <- NULL\n  returnHeaderOnly <- FALSE\n  \n  hd <- publicHeaderDescription()\n  pheader <- vector(\"list\", nrow(hd))\n  names(pheader) <- hd$Item\n  con <- file(LASfile, open = \"rb\")\n  isLASFbytes <- readBin(con, \"raw\", size = 1, n = 4, endian = \"little\")\n  pheader[[hd$Item[1]]] <- readBin(isLASFbytes, \"character\", size = 4, endian = \"little\")\n  if (! pheader[[hd$Item[1]]] == \"LASF\") {\n    stop(\"Not a valid LAS file\")\n  }\n  for (i in 2:nrow(hd)) {\n    pheader[[hd$Item[i]]] <- readBin(con, what = hd$what[i], size = hd$Rsize[i], endian = \"little\", n = hd$n[i])\n  }\n  close(con)\n  \n  numberPointRecords <- pheader[[\"Number of point records\"]]\n  offsetToPointData <- pheader[[\"Offset to point data\"]]\n  pointDataRecordLength <-pheader[[\"Point Data Record Length\"]]\n  xyzScaleOffset <- cbind(unlist(pheader[c(\"X scale factor\", \"Y scale factor\", \"Z scale factor\")]),\n                          unlist(pheader[c(\"X offset\", \"Y offset\", \"Z offset\")]))\n  \n  \n  if (returnHeaderOnly) return(pheader)\n  \n  con <- file(LASfile, open = \"rb\")\n  junk <- readBin(con, \"raw\", size = 1, n = offsetToPointData)\n  \n  if (skip > 0) {\n    junk <- readBin(con, \"raw\", size = 1, n = pointDataRecordLength * skip)\n    numberPointRecords <- numberPointRecords - skip\n  }\n  if (!is.null(nrows)) {\n    if (numberPointRecords > nrows) numberPointRecords <- nrows\n  }\n  \n  if (numberPointRecords < 1) stop(\"no records left to read\")\n  \n  allbytes <- matrix(readBin(con, \"raw\", n = pointDataRecordLength * numberPointRecords, size = 1, endian = \"little\"),\n                     ncol= pointDataRecordLength, nrow = numberPointRecords, byrow = TRUE)\n  \n  \n  close(con)\n  mm <- matrix(readBin(t(allbytes[,1:(3*4)]), \"integer\", size = 4, n = 3 * numberPointRecords, endian = \"little\"), ncol = 3, byrow = TRUE)\n  \n  mm[,1] <- mm[ ,1] * xyzScaleOffset[1,1] + xyzScaleOffset[1, 2]\n  mm[,2] <- mm[ ,2] * xyzScaleOffset[2,1] + xyzScaleOffset[2, 2]\n  mm[,3] <- mm[ ,3] * xyzScaleOffset[3,1] + xyzScaleOffset[3, 2]\n  colnames(mm) <- c(\"X\", \"Y\", \"Z\")\n  \n  gpstime <- NULL\n  if (ncol(allbytes) == 28) gpstime <- readBin(t(allbytes[ , 21:28]), \"numeric\", size = 8, n = numberPointRecords, endian = \"little\")\n    \n  Intensity <- readBin(t(allbytes[, 13:14]), \"integer\", size = 2, n = numberPointRecords, signed = FALSE, endian = \"little\")\n    \n  bytesList <- readBin(t(allbytes[,15]), \"integer\", size = 1, n = numberPointRecords, signed = FALSE, endian = \"little\")\n  ReturnNumber <- bitAnd(7, bytesList)\n  NumberOfReturns <- bitShiftR(bitAnd(56, bytesList), 3)\n  ScanDirectionFlag <- bitShiftR(bitAnd(bytesList, 64), 6)\n  EdgeofFlightLine <- bitShiftR(bitAnd(bytesList, 128), 7)\n  \n  Classification <- readBin(t(allbytes[, 16]), \"integer\", size = 1, n = numberPointRecords, signed = FALSE, endian = \"little\")\n  \n  ScanAngleRank <-readBin(t(allbytes[, 17]), \"integer\", size = 1, n = numberPointRecords, signed = TRUE, endian = \"little\")\n  \n  UserData <-readBin(t(allbytes[, 18]), \"integer\", size = 1, n = numberPointRecords, signed = FALSE, endian = \"little\")\n  \n  PointSourceID <-readBin(t(allbytes[, 19:20]), \"integer\", size = 2, n = numberPointRecords, signed = FALSE, endian = \"little\")\n    \n  R <- readBin(t(allbytes[, 23:24]), \"integer\", size = 2, n = numberPointRecords, signed = FALSE, endian = \"little\")\n  G <- readBin(t(allbytes[, 20:21]), \"integer\", size = 2, n = numberPointRecords, signed = FALSE, endian = \"little\")\n  B <- readBin(t(allbytes[, 21:22]), \"integer\", size = 2, n = numberPointRecords, signed = FALSE, endian = \"little\")\n   \n    \n    if (short) {cbind(mm, Intensity, ReturnNumber)} else {\n    cbind(mm, Intensity, ReturnNumber,NumberOfReturns,ScanDirectionFlag,EdgeofFlightLine,Classification,ScanAngleRank,gpstime,UserData,PointSourceID, R, G, B) }\n    \n    \n  \n}\n\n\npublicHeaderDescription <- function() {\n  hd <- structure(list(Item = c(\"File Signature (\\\"LASF\\\")\",\n                                \"(1.1) File Source ID\", \"(1.1) Global Encoding\",\n                                \"(1.1) Project ID - GUID data 1\", \"(1.1) Project ID - GUID data 2\",\n                                \"(1.1) Project ID - GUID data 3\", \"(1.1) Project ID - GUID data 4\",\n                                \"Version Major\", \"Version Minor\", \"(1.1) System Identifier\",\n                                \"Generating Software\", \"(1.1) File Creation Day of Year\",\n                                \"(1.1) File Creation Year\", \"Header Size\", \"Offset to point data\",\n                                \"Number of variable length records\",\n                                \"Point Data Format ID (0-99 for spec)\", \"Point Data Record Length\",\n                                \"Number of point records\", \"Number of points by return\",\n                                \"X scale factor\", \"Y scale factor\", \"Z scale factor\", \"X offset\",\n                                \"Y offset\", \"Z offset\", \"Max X\", \"Min X\", \"Max Y\", \"Min Y\", \"Max Z\",\n                                \"Min Z\"), Format = c(\"char[4]\", \"unsigned short\", \"unsigned short\",\n                                                     \"unsigned long\", \"unsigned short\", \"unsigned short\",\n                                                     \"unsigned char[8]\", \"unsigned char\", \"unsigned char\", \"char[32]\",\n                                                     \"char[32]\", \"unsigned short\", \"unsigned short\", \"unsigned short\",\n                                                     \"unsigned long\", \"unsigned long\", \"unsigned char\", \"unsigned short\",\n                                                     \"unsigned long\", \"unsigned long[5]\", \"double\", \"double\", \"double\",\n                                                     \"double\", \"double\", \"double\", \"double\", \"double\", \"double\", \"double\",\n                                                     \"double\", \"double\"), Size = c(\"4 bytes\", \"2 bytes\", \"2 bytes\",\n                                                                                   \"4 bytes\", \"2 byte\", \"2 byte\", \"8 bytes\", \"1 byte\", \"1 byte\",\n                                                                                   \"32 bytes\", \"32 bytes\", \"2 bytes\", \"2 bytes\", \"2 bytes\", \"4 bytes\",\n                                                                                   \"4 bytes\", \"1 byte\", \"2 bytes\", \"4 bytes\", \"20 bytes\", \"8 bytes\",\n                                                                                   \"8 bytes\", \"8 bytes\", \"8 bytes\", \"8 bytes\", \"8 bytes\", \"8 bytes\",\n                                                                                   \"8 bytes\", \"8 bytes\", \"8 bytes\", \"8 bytes\", \"8 bytes\"), Required =\n                         c(\"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\",\n                           \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\", \"*\",\n                           \"*\", \"*\", \"*\", \"*\", \"*\")), .Names = c(\"Item\", \"Format\", \"Size\",\n                                                                 \"Required\"), row.names = 2:33, class = \"data.frame\")\n  hd$what <- \"\"\n  hd$what[grep(\"unsigned\", hd$Format)] <- \"integer\"\n  hd$what[grep(\"char\", hd$Format)] <- \"raw\"\n  hd$what[grep(\"short\", hd$Format)] <- \"integer\"\n  hd$what[grep(\"long\", hd$Format)] <- \"integer\"\n  hd$what[grep(\"double\", hd$Format)] <- \"numeric\"\n  hd$signed <- TRUE\n  hd$signed[grep(\"unsigned\", hd$Format)] <- FALSE\n  hd$n <- as.numeric(gsub(\"[[:alpha:][:punct:]]\", \"\", hd$Format))\n  hd$n[hd$what == \"character\"] <- 1\n  hd$n[is.na(hd$n)] <- 1\n  hd$Hsize <- as.numeric(gsub(\"[[:alpha:]]\", \"\", hd$Size))\n  hd$Rsize <- hd$Hsize / hd$n\n  hd$Rsize[hd$what == \"raw\"] <- 1\n  hd$n[hd$what == \"raw\"] <- hd$Hsize[hd$what == \"raw\"]\n  hd\n}\n",
    "created" : 1415866831997.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "159500253",
    "id" : "8CBB8529",
    "lastKnownWriteTime" : 1415866860,
    "path" : "~/rLiDAR/rLiDAR/R/readLAS.r",
    "project_path" : "R/readLAS.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}